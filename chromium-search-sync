#!/usr/bin/env python3
"""
Chromium Browser Search Sync

Copyright 2025 McGroarty

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

This script detects the operating system and lists all Brave and Chrome browser profiles
with their actual names (not just directory names).

WARNING: Always back up your Brave and Chrome browser configurations before using this tool to modify your browser configuration.
Use at your own risk.

FUNCTIONALITY:
- Detects OS (macOS, Linux, Windows, Windows/Cygwin) and locates Brave and Chrome data directories
- Reads profile names from Local State file (primary source)
- Falls back to individual profile Preferences files if needed
- Handles multiple profile types: Default, Profile 1-N, System Profile
- Provides clear output showing profile names and their directory locations
- Lists search engine shortcuts for each profile or combined across all profiles
- Syncs newest search engines to all profiles with case-insensitive keyword matching
- Deletes specified search engine shortcuts from all profiles (with built-in protection)
- Filters out browser-specific URLs (brave://, chrome://) to prevent cross-browser conflicts

REQUIREMENTS:
- Python 3.6+ (uses pathlib and f-strings)
- Standard library only (no external dependencies)
- Brave and/or Chrome browser must be installed and run at least once

SEARCH ENGINE DATABASE SCHEMA:
The search engines are stored in the 'keywords' table within each profile's 'Web Data' SQLite database.

TABLE: keywords
Key fields for search engine editing:
- id (INTEGER, PRIMARY KEY): Unique identifier for each search engine
- short_name (VARCHAR, NOT NULL): Display name (e.g., "Google", "DuckDuckGo")
- keyword (VARCHAR, NOT NULL): Shortcut keyword (e.g., ":g", ":d", "csr")
- url (VARCHAR, NOT NULL): Search URL template with {searchTerms} placeholder
- favicon_url (VARCHAR, NOT NULL): URL to the search engine's favicon
- safe_for_autoreplace (INTEGER): 1 if safe to auto-replace, 0 if not
- prepopulate_id (INTEGER): ID for built-in search engines (0 for custom)
- is_active (INTEGER): 1 if currently active/default, 0 if not
- usage_count (INTEGER): Number of times this search engine has been used
- date_created (INTEGER): WebKit timestamp when created
- last_modified (INTEGER): WebKit timestamp of last modification

Additional fields:
- originating_url (VARCHAR): URL where search engine was discovered
- input_encodings (VARCHAR): Supported character encodings (typically "UTF-8")
- suggest_url (VARCHAR): URL for search suggestions
- sync_guid (VARCHAR): Unique identifier for Chrome sync
- alternate_urls (VARCHAR): JSON array of alternate URL patterns
- image_url (VARCHAR): URL template for image searches
- search_url_post_params (VARCHAR): POST parameters for search requests
- suggest_url_post_params (VARCHAR): POST parameters for suggestion requests
- image_url_post_params (VARCHAR): POST parameters for image searches
- new_tab_url (VARCHAR): URL for new tab page
- last_visited (INTEGER): WebKit timestamp of last use
- created_by_policy (INTEGER): 1 if created by enterprise policy
- created_from_play_api (INTEGER): 1 if created from Play API
- starter_pack_id (INTEGER): ID for starter pack search engines
- enforced_by_policy (INTEGER): 1 if enforced by enterprise policy
- featured_by_policy (INTEGER): 1 if featured by enterprise policy
- url_hash (BLOB): Hash of the search URL for deduplication

NOTES FOR EDITING:
- Keywords must be unique within a profile
- Built-in search engines (prepopulate_id > 0) should generally not be deleted
- WebKit timestamps are microseconds since January 1, 1601 (Windows epoch)
  Formula: webkit_timestamp = (unix_timestamp + 11644473600) * 1000000
- URLs should contain {searchTerms} placeholder for the search query
- Custom search engines typically have prepopulate_id = 0
- The database should be closed/locked when the browser is running
- IDs are auto-incrementing integers starting from 1
- Common prepopulate_id values: 1 (Google), 501 (DuckDuckGo), 550 (Brave Search)
- safe_for_autoreplace should be 1 for most search engines
- favicon_url should be provided for proper UI display

MAINTAINABILITY GUIDELINES:
- Keep functions single-purpose and well-documented
- Use clear variable names and type hints where helpful
- Handle errors gracefully with try/except blocks
- Use pathlib for cross-platform path handling
- Keep OS-specific logic centralized in detect_os()
- Add new profile types by extending the profile discovery logic
- Test on multiple operating systems when making changes

EXPECTED OUTPUT:
- Profile names should match what users see in their browser's profile switcher
"""

import os
import sys
import platform
import json
import argparse
import sqlite3
import subprocess
import time
import shutil
import re
from pathlib import Path


def detect_os():
    """Detect the operating system and return appropriate browser profile paths."""
    system = platform.system().lower()
    
    browser_paths = []
    
    if system == "darwin":  # macOS
        os_name = "macOS"
        # Check for Brave
        brave_path = Path.home() / "Library" / "Application Support" / "BraveSoftware" / "Brave-Browser"
        if brave_path.exists():
            browser_paths.append(brave_path)
        
        # Check for Chrome
        chrome_path = Path.home() / "Library" / "Application Support" / "Google" / "Chrome"
        if chrome_path.exists():
            browser_paths.append(chrome_path)
            
    elif system == "linux":
        os_name = "Linux"
        # Check for Brave
        brave_path = Path.home() / ".config" / "BraveSoftware" / "Brave-Browser"
        if brave_path.exists():
            browser_paths.append(brave_path)
        
        # Check for Chrome
        chrome_path = Path.home() / ".config" / "google-chrome"
        if chrome_path.exists():
            browser_paths.append(chrome_path)
            
    elif system == "windows":
        # Check if running under Cygwin
        if "CYGWIN" in os.environ.get("TERM", "") or \
           os.environ.get("OSTYPE", "").lower().startswith("cygwin"):
            os_name = "Windows (Cygwin)"
            # Check for Brave
            brave_path = Path.home() / "AppData" / "Local" / "BraveSoftware" / "Brave-Browser"
            if brave_path.exists():
                browser_paths.append(brave_path)
            
            # Check for Chrome
            chrome_path = Path.home() / "AppData" / "Local" / "Google" / "Chrome" / "User Data"
            if chrome_path.exists():
                browser_paths.append(chrome_path)
        else:
            print("ERROR: Running on Windows without Cygwin is not supported.")
            print("Please install Cygwin and run this script inside the Cygwin environment.")
            sys.exit(1)
    else:
        os_name = "Unknown"
    
    return os_name, browser_paths


def is_browser_specific_url(url):
    """Check if a URL is browser-specific (brave:// or chrome://)."""
    if not url:
        return False
    
    url_lower = url.lower()
    return url_lower.startswith('brave://') or url_lower.startswith('chrome://')


def get_profile_names_from_local_state(browser_path):
    """Get profile names from the Local State file."""
    local_state_file = browser_path / "Local State"
    profile_names = {}
    
    if local_state_file.exists():
        try:
            with open(local_state_file, 'r', encoding='utf-8') as f:
                local_state = json.load(f)
                if 'profile' in local_state and 'info_cache' in local_state['profile']:
                    for profile_id, profile_info in local_state['profile']['info_cache'].items():
                        profile_names[profile_id] = profile_info.get('name', profile_id)
        except (json.JSONDecodeError, IOError):
            pass
    
    return profile_names


def get_profile_name(profile_path, profile_names_cache):
    """Extract the profile name from the profile directory."""
    profile_dir_name = profile_path.name
    
    # First try to get from Local State cache
    if profile_dir_name in profile_names_cache:
        return profile_names_cache[profile_dir_name]
    
    # Fallback: try to get from individual profile Preferences
    prefs_file = profile_path / "Preferences"
    if prefs_file.exists():
        try:
            with open(prefs_file, 'r', encoding='utf-8') as f:
                prefs = json.load(f)
                # Try to get the profile name from preferences
                profile_name = prefs.get('profile', {}).get('name', '')
                if profile_name:
                    return profile_name
        except (json.JSONDecodeError, IOError):
            pass
    
    # Final fallback to directory name
    return profile_dir_name


def get_search_shortcuts(profile_path):
    """Get search engine shortcuts from a profile's Web Data SQLite database."""
    web_data_file = profile_path / "Web Data"
    shortcuts = []
    
    if not web_data_file.exists():
        return shortcuts
    
    try:
        conn = sqlite3.connect(str(web_data_file))
        cursor = conn.cursor()
        
        # Query the keywords table for search engines with non-empty keywords
        cursor.execute("""
            SELECT short_name, keyword, url 
            FROM keywords 
            WHERE keyword != '' AND keyword IS NOT NULL
            ORDER BY short_name
        """)
        
        for row in cursor.fetchall():
            short_name, keyword, url = row
            if short_name and keyword and url:
                shortcuts.append({
                    'name': short_name,
                    'keyword': keyword,
                    'url': url
                })
        
        conn.close()
        
    except (sqlite3.Error, OSError):
        pass
    
    return shortcuts


def get_search_shortcuts_with_metadata(profile_path, profile_name):
    """Get search engine shortcuts with metadata from a profile's Web Data SQLite database."""
    web_data_file = profile_path / "Web Data"
    shortcuts = []
    
    if not web_data_file.exists():
        return shortcuts
    
    try:
        conn = sqlite3.connect(str(web_data_file))
        cursor = conn.cursor()
        
        # Query the keywords table for search engines with metadata
        cursor.execute("""
            SELECT short_name, keyword, url, last_modified, favicon_url, usage_count, prepopulate_id
            FROM keywords 
            WHERE keyword != '' AND keyword IS NOT NULL
            ORDER BY short_name
        """)
        
        for row in cursor.fetchall():
            short_name, keyword, url, last_modified, favicon_url, usage_count, prepopulate_id = row
            if short_name and keyword and url:
                shortcuts.append({
                    'name': short_name,
                    'keyword': keyword,
                    'url': url,
                    'last_modified': last_modified or 0,  # Handle NULL values
                    'favicon_url': favicon_url or '',
                    'usage_count': usage_count or 0,
                    'prepopulate_id': prepopulate_id or 0,
                    'profile_name': profile_name,
                    'profile_path': str(profile_path)
                })
        
        conn.close()
        
    except (sqlite3.Error, OSError):
        pass
    
    return shortcuts


def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Chromium Browser Search Sync - Manage search engines across Brave and Chrome browser profiles",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -p          List all Brave and Chrome browser profiles
  %(prog)s -s          Show search engine shortcuts for each profile
  %(prog)s -c          Show combined search engines from all profiles (displays all versions when shortcuts differ)
  %(prog)s -cs         Sync newest search engines to all profiles
  %(prog)s -d :www     Delete search engine with shortcut ':www' from all profiles
  %(prog)s --smoke-test Run system validation checks
  %(prog)s -h          Show this help message

This script detects your operating system and lists all Brave and Chrome browser profiles
with their actual names (not just directory names).

WARNING: Always back up your Brave and Chrome browser configurations before using this tool to modify your browser configuration.
On this system, back up: ~/Library/Application Support/BraveSoftware/Brave-Browser and ~/Library/Application Support/Google/Chrome
Use at your own risk.
        """.strip()
    )
    
    parser.add_argument(
        '-p', '--profiles',
        action='store_true',
        help='List all Brave and Chrome browser profiles with their names and directories'
    )
    
    parser.add_argument(
        '-s', '--search-shortcuts',
        action='store_true',
        help='Show search engine shortcuts for each profile'
    )
    
    parser.add_argument(
        '-c', '--combined',
        action='store_true',
        help='Show combined search engines from all profiles, displaying all versions when shortcuts differ'
    )
    
    parser.add_argument(
        '-cs', '--combined-sync',
        action='store_true',
        help='Sync newest search engines to all profiles (case-insensitive keyword matching) - CAUTION: Modifies browser configuration'
    )
    
    parser.add_argument(
        '-d', '--delete',
        type=str,
        metavar='SHORTCUT',
        help='Delete search engine with specified shortcut from all profiles - CAUTION: Modifies browser configuration'
    )
    
    parser.add_argument(
        '--smoke-test',
        action='store_true',
        help='Run system validation checks to ensure the tool can operate safely'
    )
    
    return parser.parse_args()


def list_browser_profiles():
    """List all Brave and Chrome browser profiles."""
    os_name, browser_paths = detect_os()
    
    print(f"Operating System: {os_name}")
    print("-" * 50)
    
    if not browser_paths:
        print("Unsupported operating system")
        return
    
    profiles_found = False
    
    for browser_path in browser_paths:
        print(f"Checking browser data directory: {browser_path}")
        
        if not browser_path.exists():
            print(f"  Directory not found: {browser_path}")
            continue
        
        # Get profile names from Local State
        profile_names_cache = get_profile_names_from_local_state(browser_path)
        
        # Look for profile directories
        profile_dirs = []
        
        # Check for Default profile
        default_profile = browser_path / "Default"
        if default_profile.exists() and default_profile.is_dir():
            profile_dirs.append(default_profile)
        
        # Check for numbered profiles (Profile 1, Profile 2, etc.)
        for item in browser_path.iterdir():
            if item.is_dir() and item.name.startswith("Profile "):
                profile_dirs.append(item)
        
        # Check for System Profile
        system_profile = browser_path / "System Profile"
        if system_profile.exists() and system_profile.is_dir():
            profile_dirs.append(system_profile)
        
        if not profile_dirs:
            print("  No profiles found")
            continue
        
        profiles_found = True
        print(f"  Found {len(profile_dirs)} profile(s):")
        
        for profile_dir in sorted(profile_dirs):
            profile_name = get_profile_name(profile_dir, profile_names_cache)
            print(f"    - {profile_name} (Directory: {profile_dir.name})")
    
    if not profiles_found:
        print("\nNo browser profiles found on this system.")
        print("Make sure Brave and/or Chrome browser is installed and has been run at least once.")


def show_search_shortcuts():
    """Show search engine shortcuts for all profiles."""
    os_name, browser_paths = detect_os()
    
    print(f"Operating System: {os_name}")
    print("-" * 80)
    
    if not browser_paths:
        print("Unsupported operating system")
        return
    
    profiles_found = False
    
    for browser_path in browser_paths:
        if not browser_path.exists():
            continue
        
        # Get profile names from Local State
        profile_names_cache = get_profile_names_from_local_state(browser_path)
        
        # Look for profile directories
        profile_dirs = []
        
        # Check for Default profile
        default_profile = browser_path / "Default"
        if default_profile.exists() and default_profile.is_dir():
            profile_dirs.append(default_profile)
        
        # Check for numbered profiles (Profile 1, Profile 2, etc.)
        for item in browser_path.iterdir():
            if item.is_dir() and item.name.startswith("Profile "):
                profile_dirs.append(item)
        
        # Check for System Profile
        system_profile = browser_path / "System Profile"
        if system_profile.exists() and system_profile.is_dir():
            profile_dirs.append(system_profile)
        
        if not profile_dirs:
            continue
        
        profiles_found = True
        
        for profile_dir in sorted(profile_dirs):
            profile_name = get_profile_name(profile_dir, profile_names_cache)
            shortcuts = get_search_shortcuts(profile_dir)
            
            print(f"\nProfile: {profile_name} (Directory: {profile_dir.name})")
            print("-" * 80)
            
            if not shortcuts:
                print("  No search shortcuts found")
                continue
            
            # Print header
            print(f"{'Name':<30} {'Shortcut':<15} {'URL':<35}")
            print("-" * 80)
            
            # Print shortcuts
            for shortcut in sorted(shortcuts, key=lambda x: x['keyword']):
                name = shortcut['name'][:29] if len(shortcut['name']) > 29 else shortcut['name']
                keyword = shortcut['keyword'][:14] if len(shortcut['keyword']) > 14 else shortcut['keyword']
                url = shortcut['url'][:34] if len(shortcut['url']) > 34 else shortcut['url']
                
                print(f"{name:<30} {keyword:<15} {url:<35}")
    
    if not profiles_found:
        print("\nNo browser profiles found on this system.")
        print("Make sure Brave and/or Chrome browser is installed and has been run at least once.")


def show_combined_search_shortcuts():
    """Show combined search engine shortcuts from all profiles, displaying all versions with conflicts."""
    os_name, browser_paths = detect_os()
    
    print(f"Operating System: {os_name}")
    print("-" * 100)
    
    if not browser_paths:
        print("Unsupported operating system")
        return
    
    # Dictionary to store all versions of each shortcut
    all_shortcuts = {}  # keyword_lower -> list of shortcuts
    profiles_found = False
    
    for browser_path in browser_paths:
        if not browser_path.exists():
            continue
        
        # Get profile names from Local State
        profile_names_cache = get_profile_names_from_local_state(browser_path)
        
        # Look for profile directories
        profile_dirs = []
        
        # Check for Default profile
        default_profile = browser_path / "Default"
        if default_profile.exists() and default_profile.is_dir():
            profile_dirs.append(default_profile)
        
        # Check for numbered profiles (Profile 1, Profile 2, etc.)
        for item in browser_path.iterdir():
            if item.is_dir() and item.name.startswith("Profile "):
                profile_dirs.append(item)
        
        # Check for System Profile
        system_profile = browser_path / "System Profile"
        if system_profile.exists() and system_profile.is_dir():
            profile_dirs.append(system_profile)
        
        if not profile_dirs:
            continue
        
        profiles_found = True
        
        for profile_dir in profile_dirs:
            profile_name = get_profile_name(profile_dir, profile_names_cache)
            shortcuts = get_search_shortcuts_with_metadata(profile_dir, profile_name)

            # Process each shortcut (use lowercase key to avoid case collisions)
            for shortcut in shortcuts:
                # Skip browser-specific URLs that shouldn't be synced between browsers
                if is_browser_specific_url(shortcut['url']):
                    continue
                    
                keyword_lower = shortcut['keyword'].lower()

                # Add to the list of all shortcuts for this keyword
                if keyword_lower not in all_shortcuts:
                    all_shortcuts[keyword_lower] = []
                all_shortcuts[keyword_lower].append(shortcut)
    
    if not profiles_found:
        print("\nNo browser profiles found on this system.")
        print("Make sure Brave and/or Chrome browser is installed and has been run at least once.")
        return
    
    if not all_shortcuts:
        print("No search shortcuts found in any profile.")
        return
    
    print("Combined Search Engine Shortcuts")
    print("=" * 100)
    print(f"Found {len(all_shortcuts)} unique shortcuts across all profiles\n")
    
    # Print header
    print(f"{'Name':<25} {'Shortcut':<12} {'URL':<35} {'Source Profile':<18}")
    print("-" * 100)
    
    # Print shortcuts sorted by keyword (case-insensitive)
    for keyword_lower in sorted(all_shortcuts.keys()):
        shortcuts_for_keyword = all_shortcuts[keyword_lower]
        
        # Sort by last_modified descending to get newest first
        shortcuts_for_keyword.sort(key=lambda x: x['last_modified'], reverse=True)
        
        # Check if there are multiple different versions (different name or URL)
        unique_versions = []
        for shortcut in shortcuts_for_keyword:
            # Check if this version (name + URL) already exists
            version_key = (shortcut['name'], shortcut['url'])
            existing_version = None
            for uv in unique_versions:
                if (uv['name'], uv['url']) == version_key:
                    existing_version = uv
                    break
            
            if existing_version:
                # Add this profile to the existing version's profile list
                existing_version['profiles'].append(shortcut['profile_name'])
                # Update last_modified to the most recent
                if shortcut['last_modified'] > existing_version['last_modified']:
                    existing_version['last_modified'] = shortcut['last_modified']
            else:
                # New version
                unique_versions.append({
                    'name': shortcut['name'],
                    'keyword': shortcut['keyword'],
                    'url': shortcut['url'],
                    'last_modified': shortcut['last_modified'],
                    'profiles': [shortcut['profile_name']]
                })
        
        # Sort unique versions by last_modified descending
        unique_versions.sort(key=lambda x: x['last_modified'], reverse=True)
        
        # Print each unique version
        for i, version in enumerate(unique_versions):
            name = version['name'][:24] if len(version['name']) > 24 else version['name']
            keyword_display = version['keyword'][:11] if len(version['keyword']) > 11 else version['keyword']
            url = version['url'][:34] if len(version['url']) > 34 else version['url']
            
            # Format profile names
            profile_names = ', '.join(sorted(version['profiles']))
            if i == 0 and len(unique_versions) > 1:
                # This is the newest version and there are conflicts
                profile_names += " (newest)"
            
            # If profile names are too long, truncate but show it's truncated
            if len(profile_names) > 17:
                profile = profile_names[:14] + "..."
            else:
                profile = profile_names
            
            print(f"{name:<25} {keyword_display:<12} {url:<35} {profile:<18}")
    


def check_browsers_not_running():
    """Check if Brave or Chrome browser is running and exit with error if they are."""
    try:
        # Use ps to check for running browser processes
        result = subprocess.run(['ps', 'aux'], capture_output=True, text=True, check=True)
        
        # Look for browser processes with multiple possible names
        browser_processes = []
        browser_patterns = [
            'Brave Browser',
            'brave-browser', 
            'brave',
            'BraveSoftware',
            'Brave-Browser',
            'Google Chrome',
            'chrome',
            'chromium',
            'Google Chrome Helper'
        ]
        
        # Get current script name to avoid detecting ourselves
        current_script = Path(__file__).name if __file__ else 'chromium-search-sync'
        
        for line in result.stdout.split('\n'):
            # Skip helper processes and other non-main processes
            if 'Helper' in line or 'Renderer' in line or 'GPU' in line:
                continue
                
            # Skip this script itself
            if current_script in line:
                continue
                
            # Skip other scripts that might contain "brave" in their name
            # But only if they have script extensions AND contain "brave"
            if any(ext in line for ext in ['.py', '.sh', '.rb', '.js', '.pl']) and 'brave' in line.lower():
                continue
                
            # For the generic "brave" or "chrome" pattern, be more careful to avoid false positives
            # Check if any browser pattern matches (case-insensitive)
            line_lower = line.lower()
            for pattern in browser_patterns:
                pattern_lower = pattern.lower()
                if pattern_lower in line_lower:
                    # Special handling for generic patterns
                    if pattern_lower in ['brave', 'chrome']:
                        # Make sure it's not just part of a longer word like "brave-search-sync"
                        # Look for the pattern as a standalone word or as part of a path
                        # Match as a standalone executable or in a path
                        if re.search(rf'\b/.*?{pattern_lower}\b|\b{pattern_lower}\b(?!\S)', line_lower):
                            pass  # This looks like a legitimate browser process
                        else:
                            continue  # Skip this match as it's likely a false positive
                    
                    # If we get here, we found a match
                    # Extract process name and PID for display
                    parts = line.split()
                    if len(parts) >= 2:
                        pid = parts[1]
                        # Find the command part - be more flexible with extraction
                        cmd_parts = []
                        for part in parts[10:]:  # Skip standard ps columns
                            cmd_parts.append(part)
                            if len(cmd_parts) >= 2:  # Limit to prevent overly long output
                                break
                        cmd = ' '.join(cmd_parts) if cmd_parts else 'Unknown Command'
                        browser_processes.append(f"PID {pid}: {cmd}")
                    break  # Found a match, no need to check other patterns
        
        if browser_processes:
            print("ERROR: Browser is currently running!")
            print("\nThis script reads and writes browser configuration files, which is not safe")
            print("while browsers are active. Please close all browsers completely before running this script.")
            print("\nRunning browser processes detected:")
            for process in browser_processes:
                print(f"  - {process}")
            print("\nTo close browsers:")
            print("  1. Quit browsers normally (Cmd+Q on macOS, Ctrl+Q on Linux)")
            print("  2. Or use: pkill -f brave && pkill -f chrome")
            print("  3. Wait a few seconds, then run this script again")
            sys.exit(1)
            
    except subprocess.CalledProcessError:
        # ps command failed, but continue - we'll handle database locks later
        pass
    except FileNotFoundError:
        # ps command not found (unlikely on macOS/Linux), but continue
        pass


def unix_to_webkit_timestamp(unix_timestamp):
    """Convert Unix timestamp to WebKit timestamp."""
    # WebKit epoch is January 1, 1601; Unix epoch is January 1, 1970
    # Difference is 11644473600 seconds
    webkit_epoch_offset = 11644473600
    return int((unix_timestamp + webkit_epoch_offset) * 1000000)


def get_existing_keywords_case_insensitive(profile_path):
    """Get existing keywords from a profile, returning a case-insensitive set."""
    web_data_file = profile_path / "Web Data"
    keywords = set()
    
    if not web_data_file.exists():
        return keywords
    
    try:
        conn = sqlite3.connect(str(web_data_file))
        cursor = conn.cursor()
        
        cursor.execute("SELECT keyword FROM keywords WHERE keyword != '' AND keyword IS NOT NULL")
        for row in cursor.fetchall():
            keywords.add(row[0].lower())
        
        conn.close()
    except (sqlite3.Error, OSError):
        pass
    
    return keywords


def get_existing_search_engines_with_metadata(profile_path):
    """Get existing search engines with metadata from a profile for comparison and updating."""
    web_data_file = profile_path / "Web Data"
    search_engines = {}
    
    if not web_data_file.exists():
        return search_engines
    
    try:
        conn = sqlite3.connect(str(web_data_file))
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT short_name, keyword, url, last_modified, favicon_url, usage_count, prepopulate_id, id
            FROM keywords 
            WHERE keyword != '' AND keyword IS NOT NULL
        """)
        
        for row in cursor.fetchall():
            short_name, keyword, url, last_modified, favicon_url, usage_count, prepopulate_id, record_id = row
            if keyword:
                search_engines[keyword.lower()] = {
                    'id': record_id,
                    'name': short_name,
                    'keyword': keyword,
                    'url': url,
                    'last_modified': last_modified or 0,
                    'favicon_url': favicon_url or '',
                    'usage_count': usage_count or 0,
                    'prepopulate_id': prepopulate_id or 0
                }
        
        conn.close()
    except (sqlite3.Error, OSError):
        pass
    
    return search_engines


def update_search_engine(profile_path, search_engine, existing_id):
    """Update an existing search engine in a profile's database."""
    web_data_file = profile_path / "Web Data"
    
    if not web_data_file.exists():
        return False
    
    conn = None
    try:
        conn = sqlite3.connect(str(web_data_file))
        cursor = conn.cursor()
        
        # Generate current WebKit timestamp for last_modified
        # This is important for browser's sync mechanism to detect changes
        current_webkit_time = unix_to_webkit_timestamp(time.time())
        
        # Update the search engine with current timestamp
        cursor.execute("""
            UPDATE keywords SET
                short_name = ?, url = ?, favicon_url = ?, last_modified = ?
            WHERE id = ?
        """, (
            search_engine['name'],
            search_engine['url'],
            search_engine['favicon_url'],
            current_webkit_time,
            existing_id
        ))
        
        conn.commit()
        return True
        
    except (sqlite3.Error, OSError) as e:
        print(f"    Error updating search engine: {e}")
        return False
    finally:
        if conn:
            try:
                conn.close()
            except sqlite3.Error:
                pass


def insert_search_engine(profile_path, search_engine):
    """Insert a search engine into a profile's database."""
    web_data_file = profile_path / "Web Data"
    
    if not web_data_file.exists():
        return False
    
    conn = None
    try:
        conn = sqlite3.connect(str(web_data_file))
        cursor = conn.cursor()
        
        # Generate current WebKit timestamp
        current_webkit_time = unix_to_webkit_timestamp(time.time())
        
        # Insert the search engine
        cursor.execute("""
            INSERT INTO keywords (
                short_name, keyword, url, favicon_url, safe_for_autoreplace, 
                prepopulate_id, date_created, last_modified, usage_count, 
                input_encodings, suggest_url, originating_url, sync_guid,
                alternate_urls, image_url, search_url_post_params, 
                suggest_url_post_params, image_url_post_params, new_tab_url,
                last_visited, created_by_policy, created_from_play_api,
                starter_pack_id, enforced_by_policy, featured_by_policy, is_active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            search_engine['name'],
            search_engine['keyword'],
            search_engine['url'],
            search_engine['favicon_url'],
            1,  # safe_for_autoreplace
            0,  # prepopulate_id (0 for custom)
            current_webkit_time,  # date_created
            current_webkit_time,  # last_modified
            0,  # usage_count
            'UTF-8',  # input_encodings
            '',  # suggest_url
            '',  # originating_url
            '',  # sync_guid
            '[]',  # alternate_urls
            '',  # image_url
            '',  # search_url_post_params
            '',  # suggest_url_post_params
            '',  # image_url_post_params
            '',  # new_tab_url
            0,  # last_visited
            0,  # created_by_policy
            0,  # created_from_play_api
            0,  # starter_pack_id
            0,  # enforced_by_policy
            0,  # featured_by_policy
            0   # is_active
        ))
        
        conn.commit()
        return True
        
    except (sqlite3.Error, OSError) as e:
        print(f"    Error inserting search engine: {e}")
        return False
    finally:
        # Ensure connection is always closed, even if an exception occurs
        if conn:
            try:
                conn.close()
            except sqlite3.Error:
                pass  # Ignore errors when closing connection
        

def delete_search_engine(profile_path, shortcut_keyword):
    """Delete a search engine from a profile's database by keyword."""
    web_data_file = profile_path / "Web Data"
    
    if not web_data_file.exists():
        return False, "Web Data file not found"
    
    conn = None
    try:
        conn = sqlite3.connect(str(web_data_file))
        cursor = conn.cursor()
        
        # Use a transaction to ensure atomicity and prevent race conditions
        conn.execute('BEGIN IMMEDIATE')
        
        # First, check if the keyword exists and get its details
        cursor.execute("""
            SELECT short_name, keyword, prepopulate_id 
            FROM keywords 
            WHERE keyword = ? COLLATE NOCASE
        """, (shortcut_keyword,))
        
        result = cursor.fetchone()
        if not result:
            conn.rollback()
            return False, "Shortcut not found"
        
        short_name, keyword, prepopulate_id = result
        
        # Check if it's a built-in search engine (generally shouldn't be deleted)
        if prepopulate_id and prepopulate_id > 0:
            conn.rollback()
            return False, f"Built-in search engine (prepopulate_id: {prepopulate_id}) - deletion not recommended"
        
        # Delete the search engine atomically within the same transaction
        cursor.execute("DELETE FROM keywords WHERE keyword = ? COLLATE NOCASE", (shortcut_keyword,))
        deleted_count = cursor.rowcount
        
        if deleted_count > 0:
            conn.commit()
            return True, f"Deleted '{short_name}' ({keyword})"
        else:
            conn.rollback()
            return False, "No rows deleted"
        
    except (sqlite3.Error, OSError) as e:
        if conn:
            try:
                conn.rollback()
            except sqlite3.Error:
                pass  # Ignore rollback errors
        return False, f"Database error: {e}"
    finally:
        # Ensure connection is always closed, even if an exception occurs
        if conn:
            try:
                conn.close()
            except sqlite3.Error:
                pass  # Ignore errors when closing connection


def sync_search_engines_to_all_profiles():
    """Sync the newest search engines to all profiles."""
    os_name, browser_paths = detect_os()
    
    print(f"Operating System: {os_name}")
    print("=" * 80)
    print("SYNCING SEARCH ENGINES TO ALL PROFILES")
    print("=" * 80)
    
    if not browser_paths:
        print("Unsupported operating system")
        return
    
    # First, collect all search engines from all profiles (same as combined)
    combined_shortcuts = {}
    all_profiles = []
    
    for browser_path in browser_paths:
        if not browser_path.exists():
            continue
        
        # Get profile names from Local State
        profile_names_cache = get_profile_names_from_local_state(browser_path)
        
        # Look for profile directories
        profile_dirs = []
        
        # Check for Default profile
        default_profile = browser_path / "Default"
        if default_profile.exists() and default_profile.is_dir():
            profile_dirs.append(default_profile)
        
        # Check for numbered profiles (Profile 1, Profile 2, etc.)
        for item in browser_path.iterdir():
            if item.is_dir() and item.name.startswith("Profile "):
                profile_dirs.append(item)
        
        # Check for System Profile
        system_profile = browser_path / "System Profile"
        if system_profile.exists() and system_profile.is_dir():
            profile_dirs.append(system_profile)
        
        if not profile_dirs:
            continue
        
        for profile_dir in profile_dirs:
            profile_name = get_profile_name(profile_dir, profile_names_cache)
            all_profiles.append((profile_dir, profile_name))

            shortcuts = get_search_shortcuts_with_metadata(profile_dir, profile_name)

            # Process each shortcut to find the newest version (case-insensitive)
            for shortcut in shortcuts:
                # Skip browser-specific URLs that shouldn't be synced between browsers
                if is_browser_specific_url(shortcut['url']):
                    continue
                    
                keyword_lower = shortcut['keyword'].lower()

                # If we haven't seen this keyword before, or if this version is newer
                if (keyword_lower not in combined_shortcuts or
                    shortcut['last_modified'] > combined_shortcuts[keyword_lower]['last_modified']):
                    combined_shortcuts[keyword_lower] = shortcut
    
    if not all_profiles:
        print("No browser profiles found on this system.")
        return
    
    if not combined_shortcuts:
        print("No search shortcuts found in any profile.")
        return
    
    print(f"Found {len(combined_shortcuts)} unique search engines across all profiles")
    print(f"Found {len(all_profiles)} profiles to sync")
    print()
    
    # Now sync to each profile
    total_added = 0
    total_updated = 0
    
    for profile_dir, profile_name in all_profiles:
        # Check if Web Data file exists before attempting to sync
        web_data_file = profile_dir / "Web Data"
        if not web_data_file.exists():
            print(f"Skipping profile: {profile_name} (no Web Data file)")
            continue
            
        print(f"Syncing to profile: {profile_name}")
        
        # Get existing search engines with metadata for comparison
        existing_search_engines = get_existing_search_engines_with_metadata(profile_dir)
        
        added_count = 0
        updated_count = 0
        
        for _, search_engine in combined_shortcuts.items():
            keyword_lower = search_engine['keyword'].lower()
            
            if keyword_lower in existing_search_engines:
                # Search engine exists - check if it needs updating
                existing_engine = existing_search_engines[keyword_lower]
                
                # Compare to see if the newer version is different (ignore timestamps)
                needs_update = (
                    search_engine['name'] != existing_engine['name'] or
                    search_engine['url'] != existing_engine['url'] or
                    search_engine['favicon_url'] != existing_engine['favicon_url']
                )
                
                if needs_update:
                    success = update_search_engine(profile_dir, search_engine, existing_engine['id'])
                    if success:
                        print(f"  ~ Updated: {search_engine['name']} ({search_engine['keyword']})")
                        updated_count += 1
                    else:
                        print(f"  ! Failed to update: {search_engine['name']} ({search_engine['keyword']})")
                # If no update needed, don't print anything to avoid clutter
                
            else:
                # Search engine doesn't exist - add it
                success = insert_search_engine(profile_dir, search_engine)
                if success:
                    print(f"  + Added: {search_engine['name']} ({search_engine['keyword']})")
                    added_count += 1
                else:
                    print(f"  ! Failed to add: {search_engine['name']} ({search_engine['keyword']})")
        
        if added_count == 0 and updated_count == 0:
            print("  - No changes needed (all search engines are up to date)")
        else:
            changes = []
            if added_count > 0:
                changes.append(f"added {added_count}")
            if updated_count > 0:
                changes.append(f"updated {updated_count}")
            print(f"  ✓ {' and '.join(changes)} search engines")
        
        total_added += added_count
        total_updated += updated_count
        print()
    
    print("=" * 80)
    summary_parts = []
    if total_added > 0:
        summary_parts.append(f"Added {total_added} search engines")
    if total_updated > 0:
        summary_parts.append(f"Updated {total_updated} search engines")
    
    if summary_parts:
        print(f"SYNC COMPLETE: {' and '.join(summary_parts)} total across all profiles")
    else:
        print("SYNC COMPLETE: No changes needed - all search engines are up to date")
    print("=" * 80)


def delete_search_engine_from_all_profiles(shortcut_keyword):
    """Delete a search engine with the specified shortcut from all profiles."""
    os_name, browser_paths = detect_os()
    
    print(f"Operating System: {os_name}")
    print("=" * 80)
    print(f"DELETING SEARCH ENGINE SHORTCUT: '{shortcut_keyword}'")
    print("=" * 80)
    
    if not browser_paths:
        print("Unsupported operating system")
        return
    
    # Collect all profiles
    all_profiles = []
    
    for browser_path in browser_paths:
        if not browser_path.exists():
            continue
        
        # Get profile names from Local State
        profile_names_cache = get_profile_names_from_local_state(browser_path)
        
        # Look for profile directories
        profile_dirs = []
        
        # Check for Default profile
        default_profile = browser_path / "Default"
        if default_profile.exists() and default_profile.is_dir():
            profile_dirs.append(default_profile)
        
        # Check for numbered profiles (Profile 1, Profile 2, etc.)
        for item in browser_path.iterdir():
            if item.is_dir() and item.name.startswith("Profile "):
                profile_dirs.append(item)
        
        # Check for System Profile
        system_profile = browser_path / "System Profile"
        if system_profile.exists() and system_profile.is_dir():
            profile_dirs.append(system_profile)
        
        if not profile_dirs:
            continue
        
        for profile_dir in profile_dirs:
            profile_name = get_profile_name(profile_dir, profile_names_cache)
            all_profiles.append((profile_dir, profile_name))
    
    if not all_profiles:
        print("No browser profiles found on this system.")
        return
    
    print(f"Found {len(all_profiles)} profiles to check")
    print()
    
    # Delete from each profile
    total_deleted = 0
    profiles_with_shortcut = 0
    
    for profile_dir, profile_name in all_profiles:
        # Check if Web Data file exists before attempting to delete
        web_data_file = profile_dir / "Web Data"
        if not web_data_file.exists():
            print(f"Skipping profile: {profile_name} (no Web Data file)")
            continue
            
        print(f"Checking profile: {profile_name}")
        
        success, message = delete_search_engine(profile_dir, shortcut_keyword)
        
        if success:
            print(f"  ✓ {message}")
            total_deleted += 1
            profiles_with_shortcut += 1
        else:
            if "not found" in message.lower():
                print(f"  - Shortcut '{shortcut_keyword}' not found in this profile")
            else:
                print(f"  ! {message}")
                profiles_with_shortcut += 1  # It was found but couldn't be deleted
    
    print()
    print("=" * 80)
    if total_deleted > 0:
        print(f"DELETION COMPLETE: Removed '{shortcut_keyword}' from {total_deleted} profile(s)")
    else:
        if profiles_with_shortcut > 0:
            print(f"DELETION FAILED: Found '{shortcut_keyword}' in {profiles_with_shortcut} profile(s) but could not delete")
        else:
            print(f"SHORTCUT NOT FOUND: '{shortcut_keyword}' was not found in any profile")
    print("=" * 80)


def run_smoke_test():
    """Run comprehensive system validation checks."""
    print("CHROMIUM BROWSER SEARCH SYNC - SMOKE TEST")
    print("=" * 80)
    
    # Track overall test results
    test_results = []
    warnings = []
    
    # Test 1: OS Detection
    print("1. Testing OS Detection...")
    os_name, browser_paths = detect_os()
    if os_name != "Unknown" and browser_paths:
        print(f"   ✓ OS detected: {os_name}")
        print(f"   ✓ Expected browser path(s): {', '.join(str(p) for p in browser_paths)}")
        test_results.append(True)
    else:
        print(f"   ✗ OS detection failed: {os_name}")
        test_results.append(False)
    
    # Test 2: Browser Directory Structure
    print("\n2. Testing Browser Directory Structure...")
    browsers_found = False
    profiles_found = False
    
    for browser_path in browser_paths:
        # Determine browser type for user feedback
        browser_name = "Unknown Browser"
        if "BraveSoftware" in str(browser_path):
            browser_name = "Brave Browser"
        elif "Google" in str(browser_path) and "Chrome" in str(browser_path):
            browser_name = "Google Chrome"
        
        print(f"\n   Testing {browser_name}:")
        print(f"   Path: {browser_path}")
        
        if browser_path.exists():
            print(f"   ✓ Browser directory found")
            browsers_found = True
            
            # Check for Local State file
            local_state = browser_path / "Local State"
            if local_state.exists():
                print(f"   ✓ Local State file found")
            else:
                print(f"   ! Local State file missing")
                warnings.append(f"Local State file missing for {browser_name} - profile name detection may be limited")
            
            # Look for profile directories
            profile_dirs = []
            
            # Check for Default profile
            default_profile = browser_path / "Default"
            if default_profile.exists() and default_profile.is_dir():
                profile_dirs.append(default_profile)
            
            # Check for numbered profiles
            for item in browser_path.iterdir():
                if item.is_dir() and item.name.startswith("Profile "):
                    profile_dirs.append(item)
            
            # Check for System Profile
            system_profile = browser_path / "System Profile"
            if system_profile.exists() and system_profile.is_dir():
                profile_dirs.append(system_profile)
            
            if profile_dirs:
                print(f"   ✓ Found {len(profile_dirs)} profile(s)")
                profiles_found = True
                
                # Check each profile for Web Data
                for profile_dir in profile_dirs:
                    web_data = profile_dir / "Web Data"
                    if web_data.exists():
                        print(f"   ✓ Web Data found in: {profile_dir.name}")
                    else:
                        print(f"   ! Web Data missing in: {profile_dir.name}")
                        warnings.append(f"Web Data missing in {browser_name} profile: {profile_dir.name}")
            else:
                print(f"   ! No profiles found")
        else:
            print(f"   - Browser directory not found (browser not installed)")
    
    test_results.append(browsers_found)
    test_results.append(profiles_found)
    
    # Test 3: Command-line Tools
    print("\n3. Testing Required Command-line Tools...")
    import subprocess
    import shutil
    
    # Test ps command (for process checking)
    ps_available = shutil.which('ps') is not None
    if ps_available:
        print("   ✓ 'ps' command available")
        try:
            result = subprocess.run(['ps', '--version'], capture_output=True, text=True, timeout=5)
            if result.returncode == 0 or 'ps' in result.stderr.lower():
                print("   ✓ 'ps' command functional")
            else:
                print("   ! 'ps' command may not be fully functional")
                warnings.append("ps command may not work as expected")
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
            print("   ! 'ps' command test failed")
            warnings.append("ps command test failed - process detection may not work")
    else:
        print("   ! 'ps' command not found")
        warnings.append("ps command not available - process detection disabled")
    
    test_results.append(ps_available)
    
    # Test 4: SQLite Database Schema
    print("\n4. Testing SQLite Database Schema...")
    schema_valid = False
    
    for browser_path in browser_paths:
        if not browser_path.exists():
            continue
            
        # Determine browser type for user feedback
        browser_name = "Unknown Browser"
        if "BraveSoftware" in str(browser_path):
            browser_name = "Brave Browser"
        elif "Google" in str(browser_path) and "Chrome" in str(browser_path):
            browser_name = "Google Chrome"
        
        print(f"\n   Testing {browser_name} database schema:")
        
        # Get profile names from Local State
        profile_names_cache = get_profile_names_from_local_state(browser_path)
        
        # Look for profile directories with Web Data
        profile_dirs = []
        
        # Check for Default profile
        default_profile = browser_path / "Default"
        if default_profile.exists() and default_profile.is_dir():
            profile_dirs.append(default_profile)
        
        # Check for numbered profiles
        for item in browser_path.iterdir():
            if item.is_dir() and item.name.startswith("Profile "):
                profile_dirs.append(item)
        
        # Check for System Profile
        system_profile = browser_path / "System Profile"
        if system_profile.exists() and system_profile.is_dir():
            profile_dirs.append(system_profile)
        
        browser_schema_valid = False
        profiles_tested = 0
        
        for profile_dir in profile_dirs:
            web_data_file = profile_dir / "Web Data"
            if not web_data_file.exists():
                continue
                
            profile_name = get_profile_name(profile_dir, profile_names_cache)
            print(f"   Testing schema in profile: {profile_name}")
            profiles_tested += 1
            
            try:
                conn = sqlite3.connect(str(web_data_file))
                cursor = conn.cursor()
                
                # Check if keywords table exists
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='keywords'")
                if cursor.fetchone():
                    print("   ✓ 'keywords' table found")
                    
                    # Check required columns
                    cursor.execute("PRAGMA table_info(keywords)")
                    columns = [row[1] for row in cursor.fetchall()]
                    
                    required_columns = ['short_name', 'keyword', 'url', 'last_modified', 'favicon_url', 'usage_count', 'prepopulate_id']
                    missing_columns = [col for col in required_columns if col not in columns]
                    
                    if not missing_columns:
                        print("   ✓ All required columns present")
                        browser_schema_valid = True
                        schema_valid = True
                        
                        # Test a simple query
                        cursor.execute("SELECT COUNT(*) FROM keywords WHERE keyword != '' AND keyword IS NOT NULL")
                        count = cursor.fetchone()[0]
                        print(f"   ✓ Found {count} search engines with keywords")
                        
                        # Test schema by trying to read a few entries
                        cursor.execute("""
                            SELECT short_name, keyword, url, last_modified, favicon_url, usage_count, prepopulate_id
                            FROM keywords 
                            WHERE keyword != '' AND keyword IS NOT NULL
                            LIMIT 3
                        """)
                        test_rows = cursor.fetchall()
                        if test_rows:
                            print(f"   ✓ Successfully read {len(test_rows)} test entries")
                        else:
                            print("   ! No search engines found (database may be empty)")
                            warnings.append(f"No search engines found in {browser_name} database")
                    else:
                        print(f"   ✗ Missing required columns: {', '.join(missing_columns)}")
                        warnings.append(f"Missing columns in {browser_name}: {', '.join(missing_columns)}")
                else:
                    print("   ✗ 'keywords' table not found")
                    warnings.append(f"Keywords table not found in {browser_name}")
                
                conn.close()
                break  # Only need to test one profile's schema per browser
                
            except sqlite3.Error as e:
                print(f"   ✗ Database error: {e}")
                warnings.append(f"Database error in {browser_name}: {e}")
                break
        
        if profiles_tested == 0:
            print(f"   - No profiles with Web Data found for {browser_name}")
        elif browser_schema_valid:
            print(f"   ✓ {browser_name} database schema test passed")
        else:
            print(f"   ✗ {browser_name} database schema test failed")
    
    test_results.append(schema_valid)
    
    # Test 5: Write Permission Test
    print("\n5. Testing Write Permissions...")
    write_test_passed = True
    
    for browser_path in browser_paths:
        if not browser_path.exists():
            continue
            
        # Determine browser type for user feedback
        browser_name = "Unknown Browser"
        if "BraveSoftware" in str(browser_path):
            browser_name = "Brave Browser"
        elif "Google" in str(browser_path) and "Chrome" in str(browser_path):
            browser_name = "Google Chrome"
        
        print(f"\n   Testing {browser_name} write permissions:")
        
        # Test write permission on browser directory (read-only check)
        try:
            if os.access(str(browser_path), os.W_OK):
                print(f"   ✓ Write permission confirmed for browser directory")
            else:
                print(f"   ✗ Write permission denied for browser directory")
                write_test_passed = False
        except (OSError, PermissionError) as e:
            print(f"   ✗ Cannot check write permission for browser directory")
            print(f"      Error: {e}")
            write_test_passed = False
        
        # Test write permission on profile Web Data files
        profile_dirs = []
        
        # Check for Default profile
        default_profile = browser_path / "Default"
        if default_profile.exists() and default_profile.is_dir():
            profile_dirs.append(default_profile)
        
        # Check for numbered profiles
        for item in browser_path.iterdir():
            if item.is_dir() and item.name.startswith("Profile "):
                profile_dirs.append(item)
        
        # Check for System Profile
        system_profile = browser_path / "System Profile"
        if system_profile.exists() and system_profile.is_dir():
            profile_dirs.append(system_profile)
        
        profiles_tested = 0
        for profile_dir in profile_dirs:
            web_data_file = profile_dir / "Web Data"
            if web_data_file.exists():
                try:
                    # Test if file is writable
                    if os.access(str(web_data_file), os.W_OK):
                        print(f"   ✓ Write permission confirmed for: {profile_dir.name}/Web Data")
                    else:
                        print(f"   ✗ Write permission denied for: {profile_dir.name}/Web Data")
                        write_test_passed = False
                    profiles_tested += 1
                except OSError as e:
                    print(f"   ✗ Cannot check write permission for: {profile_dir.name}/Web Data")
                    print(f"      Error: {e}")
                    write_test_passed = False
        
        if profiles_tested == 0:
            print(f"   - No Web Data files found for {browser_name}")
        else:
            print(f"   ✓ Tested {profiles_tested} Web Data files for {browser_name}")
    
    test_results.append(write_test_passed)
    
    # Final Assessment
    print("\n" + "=" * 80)
    print("SMOKE TEST RESULTS")
    print("=" * 80)
    
    # Show which browsers were tested
    print("BROWSERS TESTED:")
    browsers_tested = []
    for browser_path in browser_paths:
        if browser_path.exists():
            if "BraveSoftware" in str(browser_path):
                browsers_tested.append("Brave Browser")
            elif "Google" in str(browser_path) and "Chrome" in str(browser_path):
                browsers_tested.append("Google Chrome")
            else:
                browsers_tested.append(f"Unknown Browser ({browser_path.name})")
    
    if browsers_tested:
        for browser in browsers_tested:
            print(f"  ✓ {browser}")
    else:
        print("  ! No browsers found or installed")
    
    print()
    
    all_tests_passed = all(test_results)
    
    if all_tests_passed:
        print("✓ ALL TESTS PASSED")
        print("\nASSESSMENT: NO PROBLEMS FOUND")
        print("The tool should work correctly on this system.")
    else:
        print("✗ SOME TESTS FAILED")
        print("\nASSESSMENT: PROBLEMS DETECTED")
        print("The tool may not work correctly or could cause issues.")
        print("Please resolve the failed tests before using this tool.")
    
    if warnings:
        print(f"\n⚠ WARNINGS ({len(warnings)}):")
        for i, warning in enumerate(warnings, 1):
            print(f"  {i}. {warning}")
    
    print("\nTEST SUMMARY:")
    test_names = [
        "OS Detection",
        "Browser Directory Structure", 
        "Profile Detection",
        "Command-line Tools",
        "SQLite Schema",
        "Write Permissions"
    ]
    
    for i, (test_name, passed) in enumerate(zip(test_names, test_results)):
        status = "✓ PASS" if passed else "✗ FAIL"
        print(f"  {test_name}: {status}")
    
    print("=" * 80)
    
    return all_tests_passed


def get_backup_directory_message():
    """Get the backup directory message for the current OS."""
    os_name, browser_paths = detect_os()
    
    if browser_paths:
        backup_path = str(browser_paths[0]).replace(str(Path.home()), "~")
        return f"On this system, back up your browser configuration directories"
    else:
        return "Back up your browser configuration directories"


if __name__ == "__main__":
    try:
        args = parse_arguments()
        
        # Skip browser check for smoke test as it's a validation tool
        if not args.smoke_test:
            check_browsers_not_running()
        
        if args.profiles:
            list_browser_profiles()
        elif args.search_shortcuts:
            show_search_shortcuts()
        elif args.combined:
            show_combined_search_shortcuts()
        elif args.combined_sync:
            sync_search_engines_to_all_profiles()
        elif args.delete:
            delete_search_engine_from_all_profiles(args.delete)
        elif args.smoke_test:
            run_smoke_test()
        else:
            # If no arguments provided, show help
            backup_msg = get_backup_directory_message()
            parser = argparse.ArgumentParser(
                description="Chromium Browser Search Sync - Manage search engines across Brave and Chrome browser profiles",
                formatter_class=argparse.RawDescriptionHelpFormatter,
                epilog=f"""
Examples:
  %(prog)s -p          List all Brave and Chrome browser profiles
  %(prog)s -s          Show search engine shortcuts for each profile
  %(prog)s -c          Show combined search engines from all profiles
  %(prog)s -cs         Sync newest search engines to all profiles
  %(prog)s -d :www     Delete search engine with shortcut ':www' from all profiles
  %(prog)s --smoke-test Run system validation checks
  %(prog)s -h          Show this help message

This script detects your operating system and lists all Brave and Chrome browser profiles
with their actual names (not just directory names).

WARNING: Always back up your browser configurations before using this tool to modify your browser configuration.
{backup_msg}
Use at your own risk.
                """.strip()
            )
            parser.add_argument(
                '-p', '--profiles',
                action='store_true',
                help='List all Brave and Chrome browser profiles with their names and directories'
            )
            parser.add_argument(
                '-s', '--search-shortcuts',
                action='store_true',
                help='Show search engine shortcuts for each profile'
            )
            parser.add_argument(
                '-c', '--combined',
                action='store_true',
                help='Show combined search engines from all profiles (most recent version of each shortcut)'
            )
            parser.add_argument(
                '-cs', '--combined-sync',
                action='store_true',
                help='Sync newest search engines to all profiles (case-insensitive keyword matching) - CAUTION: Modifies browser configuration'
            )
            parser.add_argument(
                '-d', '--delete',
                type=str,
                metavar='SHORTCUT',
                help='Delete search engine with specified shortcut from all profiles - CAUTION: Modifies browser configuration'
            )
            parser.add_argument(
                '--smoke-test',
                action='store_true',
                help='Run system validation checks to ensure the tool can operate safely'
            )
            parser.print_help()
            
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred: {e}")
        sys.exit(1)
